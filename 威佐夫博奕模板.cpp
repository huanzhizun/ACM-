e//有两堆各若干个物品,两个人轮流从某一堆或同时从两堆中取同样多的物品,规定每次至少取一个,多者不限,最后取光者得胜.这种规则下游戏是颇为复杂的。我们用（a[k]，b[k]）（a[k] ≤ b[k] ,k=0，1，2，...,n)表示两堆物品的数量并称其为局势。如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。
//奇异局势下先手必败，非奇异局势下先手必胜。
//这种情况下是颇为复杂的.我们用(ak,bk)(ak ≤bk ,k=0,1,2,...,n)表示两堆物品的数量并称其为局势,如果甲面对(0,0),那么甲已经输了,这种局势我们称为奇异局势.前几个奇异局势是：(0,0)、(1,2)、(3,5)、(4,7)、(6,10)、(8,13)、(9,15)、(11,18)、(12,20).
//可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而bk= ak + k,奇异局势有如下三条性质：
//1、任何自然数都包含在一个且仅有一个奇异局势中.
//由于ak是未在前面出现过的最小自然数,所以有ak > ak-1 ,而bk= ak + k > ak-1 + k-1 = bk-1 > ak-1 .所以性质1.成立.
//2、任意操作都可将奇异局势变为非奇异局势.
//事实上,若只改变奇异局势(ak,bk)的某一个分量,那么另一个分量不可能在其他奇异局势中,所以必然是非奇异局势.如果使(ak,bk)的两个分量同时减少,则由于其差不变,且不可能是其他奇异局势的差,因此也是非奇异局势.
//3、采用适当的方法,可以将非奇异局势变为奇异局势.
//假设面对的局势是(a,b),若b = a,则同时从两堆中取走a 个物体,就变为了奇异局势(0,0)；如果a = ak ,b > bk,那么,取走b - bk个物体,即变为奇异局势；如果a = ak , b < bk ,则同时从两堆中拿走ak - ab - ak个物体,变为奇异局势( ab - ak , ab - ak+ b - ak)；如果a > ak ,b= ak + k,则从一堆中拿走多余的数量a - ak 即可；如果a < ak ,b= ak + k,分两种情况,第一种,a=aj (j < k),从第二堆里面拿走b - bj 即可；第二种,a=bj (j < k),从第二堆里面拿走b - aj 即可.
//从如上性质可知,两个人如果都采用正确操作,那么面对非奇异局势,先拿者必胜；反之,则后拿者取胜.
//那么任给一个局势(a,b),怎样判断它是不是奇异局势呢？我们有如下公式：

//ak =[k(1+√5)/2](下取整), bk= ak + k (k∈N)
//奇妙的是其中出现了有关黄金分割数的式子：(1+√5)/2 =1.618...,若两堆物品个数分别为x,y(x<y)，则k=y-x，再判断x是否等于[(y-x)*( √5+1)/2] 即可得知是否是奇异局势。
#include<stdio.h>
#include<iostream>
#include<algorithm>
#include<math.h>
#define eps 1e-10
using namespace std;
const double jin=(1.0+sqrt(5.0))/2;
int main()
{
    int n,p,k,f;
    while(scanf("%d%d",&n,&p)!=EOF)
    {
        if(n==p)
        {
            printf("1\n");
            continue;
        }
        if(n>p)
            swap(n,p);
        k=p-n;
        f=(int)floor(k*jin+eps);
        if(f==n)
            printf("1\n");
        else
            printf("0\n");
    }
    return 0;
}